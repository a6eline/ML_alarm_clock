diff --git a/RTC_and_LCD.cpp b/RTC_and_LCD.cpp
index fc72e6a..8ccc923 100644
--- a/RTC_and_LCD.cpp
+++ b/RTC_and_LCD.cpp
@@ -34,22 +34,28 @@
 #include <EEPROM.h>
 
 // Creating objects of the LCD and RTC 
-LiquidCrystal lcd(5, 6, 7, 8, 9, 10); //Pins: RS, E, D4, D5, D6, D7
-RTC_DS3231 rtc; 
+static LiquidCrystal lcd(5, 6, 7, 8, 9, 10); //Pins: RS, E, D4, D5, D6, D7
+static RTC_DS3231 rtc;
 
 //---------------------------------------------------------------------RTC----------------------------------------------------------------------------------------------
 
 // RTC_and_LCD.cpp --- checks if the I2C communication is successful and if the RTC module has power
-void checkRTC(void) {
+void checkRTC() {
   // try to initialize RTC 
-  Serial.println(); Serial.println(); 
+  Serial.println();
+  Serial.println();
   Serial.println("Checking RTC"); 
-  lcd.clear(); lcd.setCursor(0, 0);
-  lcd.println("Checking RTC"); delay(2000); lcd.clear();
+
+  lcd.clear();
+  lcd.setCursor(0, 0);
+  lcd.println("Checking RTC");
+
+  delay(2000);
+  lcd.clear();
 
   //-------------------------CHECK-I2C/RTC-------------------------------
   // Check if I2C communication with RTC is unsuccessful
-  while ( !rtc.begin() ) { 
+  while (!rtc.begin()) {
     lcd.clear(); lcd.setCursor(0, 0); 
     lcd.print("RTC ERROR"); Serial.println("RTC ERROR");
     delay(1000); // wait before printing next message
@@ -58,28 +64,27 @@ void checkRTC(void) {
     lcd.print("Check connections"); Serial.println("Check connections");
     delay(2000); // wait 2 seconds before halting the program
 
-    while (1); } // Halt the program after one failed RTC initialization attempt
+    while (1); // Halt the program after one failed RTC initialization attempt
+  }
 
   //-------------------------CHECK-POWER-------------------------------
   // If RTC has lost power
   if (rtc.lostPower()) { 
     lcd.print("RTC lost power");
     Serial.println("RTC lost power..."); 
-    rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); }
-  
-  //-------------------------INITIALISED!-------------------------------
+    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
+  } //-------------------------INITIALISED!-------------------------------
   else {
     lcd.print("RTC Initialized");
-    Serial.println("RTC Initialized"); }
+    Serial.println("RTC Initialized");
+  }
   
   Serial.println();  
   delay(2000); // display message for 2 seconds
 }
 
-
 // RTC_and_LCD.cpp --- set up the RTC module's pins, attatch pin interupt, disable previous alarms and more - check 
-void rtc_setup(void) {
-
+void rtc_setup() {
   // ONLY SET TIME ONCE 
   // rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); 
 
@@ -89,7 +94,10 @@ void rtc_setup(void) {
   
   // set alarm 1, 2 flag to false (so alarm 1, 2 didn't happen so far)
   // if not done, this easily leads to problems, as both register aren't reset on reboot/recompile
-  rtc.disableAlarm(1); rtc.clearAlarm(1); rtc.disableAlarm(2); rtc.clearAlarm(2); 
+  rtc.disableAlarm(1);
+  rtc.clearAlarm(1);
+  rtc.disableAlarm(2);
+  rtc.clearAlarm(2);
   
   // turn off alarm 2 (in case it isn't off already)
   // again, this isn't done at reboot, so a previously set alarm could easily go overlooked
@@ -99,28 +107,29 @@ void rtc_setup(void) {
 //----------------------------------------------------------------LCD-1602---------------------------------------------------------------------------------------------------
 
 // RTC_and_LCD.cpp --- clear LCD, print success signal and set the screen to 16x2
-void lcd_setup(void) {
-  lcd.begin(16,2); // setting up the screen to be 16x2
+void lcd_setup() {
+  lcd.begin(16, 2); // setting up the screen to be 16x2
   lcd.print("LCD Sucessful!!"); // update message to signal it is fine
-  delay(2000); lcd.clear();
+  delay(2000);
+  lcd.clear();
 }
 
 // RTC_and_LCD.cpp --- testing the LCD by outputting a string
-void lcd_test(void) {
+void lcd_test() {
   lcd.setCursor(0, 0);
   lcd.print("Test");
 }
 
 // array to convert weekday number to a string ---> dayNames[0] = Sun, 1 = Mon, 2 = Tue...
-const char* dayNames[] = {"Sun" , "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
+constexpr const char* dayNames[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
 
 // RTC_and_LCD.cpp --- display the current time onto the LCD screen via DS3231 RTC data. This setup is kind of ugly, I might change it in the future :P
-void display_time(void) {
-  static unsigned long display_millis = millis(); // a static variable so it only executes once at the start
-  const int one_sec = 1000;                       // 1000 millis is 1 second
+void display_time() {
+  constexpr auto one_sec = 1000;         // 1000 millis is 1 second
+  static auto display_millis = millis(); // a static variable so it only executes once at the start
 
   if (millis() - display_millis > one_sec) {
-    DateTime now = rtc.now();                     // update the now time
+    const auto now = rtc.now();                   // update the now time
     lcd.clear();                                  // Clear the LCD screen
 
     //-------------------------DISPLAY-WEEKDAY-------------------------------
@@ -129,15 +138,17 @@ void display_time(void) {
     lcd.print(' ');                               // printing whitespace before time display
 
     //-------------------------DISPLAY-12HR-------------------------------
-    int hour = now.hour() % 12;
+    auto hour = now.hour() % 12;
     if (hour == 0) hour = 12;                     // adjust for 12-hour format
     if (hour < 10) lcd.print('0');                // add leading zero for hour if necessary
-    lcd.print(hour, DEC); lcd.print(':');         // printing the current time hour
+    lcd.print(hour, DEC);                         // printing the current time hour
+    lcd.print(':');
 
     //-------------------------DISPLAY-MINUTE-------------------------------
     if (now.minute() < 10) lcd.print('0');        // add leading zero for minute if necessary
-    lcd.print(now.minute(), DEC); lcd.print(':'); // print the current minute
-    
+    lcd.print(now.minute(), DEC); // print the current minute
+    lcd.print(':');
+
     //-------------------------DISPLAY-SECOND-------------------------------
     if (now.second() < 10) lcd.print('0');        // add leading zero for second if necessary
     lcd.print(now.second(), DEC);                 // print the current second
@@ -146,11 +157,13 @@ void display_time(void) {
     //-------------------------DISAPLY-DAY-------------------------------
     lcd.setCursor(0, 1);                          // set cursor to column 0, row 1
     if (now.day() < 10) lcd.print('0');           // add leading zero for day if necessary
-    lcd.print(now.day(), DEC); lcd.print('.');    // print the current day 
-    
+    lcd.print(now.day(), DEC);                    // print the current day
+    lcd.print('.');
+
     //-------------------------DISPLAY-DATE-------------------------------
     if (now.month() < 10) lcd.print('0');         // add leading zero for month if necessary
-    lcd.print(now.month(), DEC); lcd.print('.');  // print the current month
+    lcd.print(now.month(), DEC);                  // print the current month
+    lcd.print('.');
     lcd.print(now.year(), DEC);                   // print the current year
     
     //-------------------------UPDATE-MILLIS-------------------------------
@@ -162,14 +175,19 @@ void display_time(void) {
 
 // RTC_and_LCD.cpp --- this is a timer which can go from seconds to hours 
 void timer(int hour, int minute, int second, Ds3231Alarm1Mode alarm_mode) {
-  Serial.println(); Serial.print("TIMER --> "); 
-  Serial.print(hour); Serial.print(" hr(s) and "); Serial.print(minute); Serial.print(" min(s) and "); Serial.print(second); Serial.print(" sec(s)"); 
+  Serial.println();
+  Serial.print("TIMER --> ");
+  Serial.print(hour);
+  Serial.print(" hr(s) and ");
+  Serial.print(minute);
+  Serial.print(" min(s) and ");
+  Serial.print(second);
+  Serial.print(" sec(s)");
 
   if (!rtc.setAlarm1 (rtc.now() + TimeSpan(0, hour, minute, second), alarm_mode) ) {
-        Serial.println(" from now was NOT set!");
-  }
-  else {
-      Serial.println (" from now was SUCCESSFULLY set!");
+    Serial.println(" from now was NOT set!");
+  } else {
+    Serial.println (" from now was SUCCESSFULLY set!");
   }
 }
 
@@ -197,63 +215,75 @@ void timer(int hour, int minute, int second, Ds3231Alarm1Mode alarm_mode) {
 // void set_daily_alarm(int hour, int minute, char meridiem[2]) // meridiem is a 
 
 // RTC_and_LCD.cpp --- this function sets an alarm everyday for HOUR:MINUTE in 24hr code
-void set_daily_alarm(int hour, int minute) {
+void set_daily_alarm(const AlarmTime& time) {
+  const auto& [hour, minute, second] = time;
+
   // "Alarm for HH:MM has NOT/SUCCESSFULLY been set"
   Serial.println();
-  Serial.print("ALARM ---> "); Serial.print(hour); Serial.print(":"); Serial.print(minute);
-
-  if(!rtc.setAlarm1(DateTime(0, 0, 0, hour, minute, 0), DS3231_A1_Hour)) {
-      Serial.println(" has NOT been set! (ERROR)");
-  }
-  else {
-      Serial.println(" has SUCCESSFULLY been set!");
+  Serial.print("ALARM ---> ");
+  Serial.print(hour);
+  Serial.print(":");
+  Serial.print(minute);
+
+  if (rtc.setAlarm1(DateTime(0, 0, 0, hour, minute, second), AlarmMode::A1_HOUR)) {
+    Serial.println(" has SUCCESSFULLY been set!");
+  } else {
+    Serial.println(" has NOT been set! (ERROR)");
   }
 }
 
 // RTC_and_LCD.cpp --- this sets a hardcoded alarm for debugging 
-void set_alarm(void) {
-    if(!rtc.setAlarm1(DateTime(0, 0, 0, 0, 0, 0), DS3231_A1_Second)) {
-        Serial.println("Error, alarm for every minute wasn't set!");
-    }
-    else {
-        Serial.println("Alarm is set for every minute!");
-    }
+void set_alarm() {
+  if (rtc.setAlarm1(DateTime(0, 0, 0, 0, 0, 0), AlarmMode::A1_SECOND)) {
+    Serial.println("Alarm is set for every minute!");
+  } else {
+    Serial.println("Error, alarm for every minute wasn't set!");
+  }
 }
 
 //------------------------------------------------------------------DELETE-ALARM-------------------------------------------------------------------------------------------------
 
 // RTC_and_LCD.cpp --- deletes alarm, which is needed to clear the fired state. This alarm should be set again after triggered output state (such as buzzeer or LED) is turned off.
-void delete_alarm(int alarmNumber) {
-  // There can only be alarm 1 or 2 - other numbers can result in a bug
-  if ( alarmNumber == 1 || alarmNumber == 2 ) {
-    rtc.disableAlarm(alarmNumber);    // disable the specified alarm
-    rtc.clearAlarm(alarmNumber);      // clear the specified alarm
-
-        // digitalWrite(CLOCK_INTERRUPT_PIN, LOW);  // Set the interrupt pin LOW
-        delay(200);
-
-    rtc.writeSqwPinMode(DS3231_OFF);  // disable square wave output
-    rtc.clearAlarm(alarmNumber);      // clear lingering flags
-    Serial.print("    Interrupt pin state after clearing alarm: ");
-    Serial.println(digitalRead(CLOCK_INTERRUPT_PIN));
-
-    if (digitalRead( CLOCK_INTERRUPT_PIN) == HIGH ) {
-      Serial.println("       -- ALARM cleared successfully."); } 
-    else {
-      Serial.println("       -- ERROR: Failed to clear alarm."); } 
-  }
-  else {
-    Serial.println("Wrong parameter inputted for delete_alarm function in RTC_and_LCD.cpp");
+void delete_alarm(Alarm alarm) {
+  constexpr int alarm_numbers[] = {
+    [(int) Alarm::Alarm1] = 1, // NOTE (remove before merging): The compiler may yell at you for this because array initializers are a GNU extension
+    [(int) Alarm::Alarm2] = 2
+  };
+
+  const auto alarm_num = alarm_numbers[alarm];
+
+  // NOTE (remove before merging): If the above does not compile then remove it and uncomment this, otherwise you can delete it
+  // const auto alarm_num = [&]() -> int {
+  //   switch (alarm) {
+  //   case Alarm::Alarm1: return 1;
+  //   case Alarm::Alarm2: return 2;
+  //   }
+  // }();
+
+  rtc.disableAlarm(alarm_num);    // disable the specified alarm
+  rtc.clearAlarm(alarm_num);      // clear the specified alarm
+
+  // digitalWrite(CLOCK_INTERRUPT_PIN, LOW);  // Set the interrupt pin LOW
+  delay(200);
+
+  rtc.writeSqwPinMode(DS3231_OFF);  // disable square wave output
+  rtc.clearAlarm(alarm_num);      // clear lingering flags
+
+  const auto pin = digitalRead(CLOCK_INTERRUPT_PIN);
+  Serial.print("    Interrupt pin state after clearing alarm: ");
+  Serial.println(pin);
+
+  if (pin == HIGH) {
+    Serial.println("       -- ALARM cleared successfully.");
+  } else {
+    Serial.println("       -- ERROR: Failed to clear alarm.");
   }
 }
 
 //------------------------------------------------------------------ALARM-FIRED-BOOL-------------------------------------------------------------------------------------------------
 
-bool alarm_fired(void) {
-  if (digitalRead( CLOCK_INTERRUPT_PIN) == HIGH ) {
-    return 1; }
-  else {
-    return 0; }
+bool alarm_fired() {
+  return (digitalRead(CLOCK_INTERRUPT_PIN) == HIGH);
 }
 
 //-------------------------------------------------------------------MISC------------------------------------------------------------------------------------------------
@@ -262,6 +292,3 @@ bool alarm_fired(void) {
 void on_alarm() {
     Serial.println("    -- ALARM occured!");
 }
-
-
-
diff --git a/RTC_and_LCD.h b/RTC_and_LCD.h
index 5009190..7b98fa7 100644
--- a/RTC_and_LCD.h
+++ b/RTC_and_LCD.h
@@ -8,54 +8,105 @@
 #include <LiquidCrystal.h>
 #include <Wire.h>
 
-#define CLOCK_INTERRUPT_PIN 4
+constexpr auto CLOCK_INTERRUPT_PIN = 4;
 
 // ------------------------ ENUM-ALIASING -------------------------------
 
 // Ds3231Alarm1Mode & Ds3231Alarm2Mode is defined in RTClib.h line 55-76
 //  ^ https://github.com/adafruit/RTClib/blob/master/src/RTClib.h#L378
 
-// renaming Ds3231Alarm1Mode for better readability
-constexpr auto A1_SECOND  =   DS3231_A1_Second;
-constexpr auto A1_MINUTE  =   DS3231_A1_Minute;
-constexpr auto A1_HOUR    =   DS3231_A1_Hour;
+namespace AlarmMode {
+  // renaming Ds3231Alarm1Mode for better readability
+  constexpr auto A1_SECOND = DS3231_A1_Second;
+  constexpr auto A1_MINUTE = DS3231_A1_Minute;
+  constexpr auto A1_HOUR   = DS3231_A1_Hour;
 
-// renaming Ds3231Alarm1Mode for better readability
-constexpr auto A2_MINUTE  =   DS3231_A2_Minute;
-constexpr auto A2_HOUR    =   DS3231_A2_Hour;
+  // renaming Ds3231Alarm2Mode for better readability
+  constexpr auto A2_MINUTE = DS3231_A2_Minute;
+  constexpr auto A2_HOUR   = DS3231_A2_Hour;
+};
+
+enum class Alarm {Alarm1, Alarm2}:
+
+struct AlarmTime {
+  uint32_t hour = 0;
+  uint32_t minute = 0;
+  uint32_t second = 0;
+};
+
+using AlarmDuration = AlarmTime;
 
 //------------------------SETUP-------------------------------
 
-void checkRTC(void);      // checks if the RTC is working and if power is on
-void rtc_setup(void);     // setup for RTC (pins and such)
+void checkRTC();      // checks if the RTC is working and if power is on
+void rtc_setup();     // setup for RTC (pins and such)
 
 //------------------------LCD-------------------------------
 
-void lcd_setup(void);     // set up the LCD screen
-void lcd_test(void);      // test LCD when pinning new board
-void display_time(void);  // display the time on LCD --> may change the setup soon since its a bit ugly
+void lcd_setup();     // set up the LCD screen
+void lcd_test();      // test LCD when pinning new board
+void display_time();  // display the time on LCD --> may change the setup soon since its a bit ugly
 
 //------------------------TIMER-------------------------------
 
-void timer(int hour, int minute, int second, Ds3231Alarm1Mode alarm_mode);
-// template <typename alarmT> 
-//   void timer_template(int hour, int minute, int second, alarmT alarm_mode);
+template<Alarm alarm> struct DefaultMode {};
+template<> struct DefaultMode<Alarm::Alarm1> { static constexpr auto mode = AlarmMode::A1_HOUR; }:
+template<> struct DefaultMode<Alarm::Alarm2> { static constexpr auto mode = AlarmMode::A2_HOUR; }:
+
+// NOTE (remove before merging): You can use this instead of the DefaultMode type traits if you want
+/*
+template<Alarm alarm>
+constexpr auto default_mode() {
+  if constexpr (alarm == Alarm::Alarm1)
+    return AlarmMode::A1_HOUR;
+  else if constexpr (alarm == Alarm::Alarm1)
+    return AlarmMode::A2_HOUR;
+};
+*/
+
+template<Alarm alarm, typename M>
+void set_timer(const AlarmDuration& duration, M mode = DefaultMode<alarm>::mode) {
+  const auto& [hour, minute, second] = duration;
+
+  Serial.println();
+  Serial.print("TIMER --> ");
+  Serial.print(hour);
+  Serial.print(" hr(s) and ");
+  Serial.print(minute);
+  Serial.print(" min(s) and ");
+  Serial.print(second);
+  Serial.print(" sec(s)");
+
+  if constexpr (alarm == AlarmMode::Alarm1) {
+    if (rtc.setAlarm1(rtc.now() + TimeSpan(0, hour, minute, second), mode)) {
+      Serial.println(" from now was SUCCESSFULLY set!");
+    } else {
+      Serial.println(" from now was NOT set!");
+    }
+  } else if constexpr (alarm == AlarmMode::Alarm2) {
+    if (rtc.setAlarm2(rtc.now() + TimeSpan(0, hour, minute, second), mode)) {
+      Serial.println(" from now was SUCCESSFULLY set!");
+    } else {
+      Serial.println(" from now was NOT set!");
+    }
+  }
+}
 
 //------------------------ALARM-------------------------------
 
-void set_alarm(void);     // sets a hardcoded alarm for debug 
-void set_daily_alarm(int hour, int minute); // sets a daily alarm (24HR parameters)
+void set_alarm(); // sets a hardcoded alarm for debug
+void set_daily_alarm(const AlarmTime& time); // sets a daily alarm (24HR parameters)
 
 //------------------------RESET-------------------------------
 
-void delete_alarm(int alarmNumber); // deletes the alarm for it to be reset
+void delete_alarm(Alarm alarm); // deletes the alarm for it to be reset
 
 //------------------------FIRED-------------------------------
 
-bool alarm_fired(void);   // checks if alarm has been fired or not --> will be used soon 
+bool alarm_fired(); // checks if alarm has been fired or not --> will be used soon
 
 //------------------------MISC-------------------------------
-void on_alarm();          // serial.print when alarm occures, used in --> rtc_setup attatchInterupt() function
+void on_alarm(); // serial.print when alarm occures, used in --> rtc_setup attatchInterupt() function
 
 // // header for renaming 
 
@@ -71,7 +122,7 @@ void on_alarm();          // serial.print when alarm occures, used in --> rtc_se
 // template<AlarmMode mode>
 // auto set_timer(const Duration& duration) -> void
 // {
-// 	auto& [hour, minute, second] = duration;
+// 	   auto& [hour, minute, second] = duration;
 
 //     Serial.print("Alarm for "); 
 //     Serial.print(minute); Serial.print(" min(s) and "); Serial.print(second); Serial.print(" sec(s)"); 
diff --git a/alarm_main.ino b/alarm_main.ino
index 80ca5ee..263ecd5 100644
--- a/alarm_main.ino
+++ b/alarm_main.ino
@@ -44,122 +44,115 @@
 
 //---------------------------------FINITE-STATE-MACHINE-ENUM---------------------------------------
 // this enum is for the states which the alarm will have
-enum class ALARM_STATE : uint8_t { 
-  DEFAULT_STATE,  // input alarm    --> inputting alarm fired     ---> state = ALARM_OFF
-  ALARM_ON,       // beeps buzzer   --> inputting button pressed  ---> state = ALARM_ON
-  ALARM_OFF,      // silence buzzer --> deletes alarm             ---> state = DEFAULT
+enum class AlarmState : uint8_t {
+  Default,       // input alarm    --> inputting alarm fired     ---> state = AlarmOff
+  AlarmOn,       // beeps buzzer   --> inputting button pressed  ---> state = AlarmOn
+  AlarmOff       // silence buzzer --> deletes alarm             ---> state = DEFAULT
 }; // ^^^ A STATE TO CHECK VOICE COMMANDS WILL BE ADDED SOON 
 
+// NOTE (remove before merging): Is a default state even required? What other state is there besides the alarm being on/off? Try drawing out the FSA
+
 
 //---------------------------------------------------------------------SETUP----------------------------------------------------------------------------------------------
 
 void setup() {
-
   delay(1000); // delay to allow certain boards to upload safely
 
   //------------------------------------------SETUP-FUNCTIONS---------------------------------------
   lcd_setup(); // setup the LCD
-  checkRTC(); rtc_setup(); // check that the rtc is working 
+  checkRTC();
+  rtc_setup(); // check that the rtc is working
   display_time();
   serial_setup(); 
-  led_setup(); buzzer_setup(); button_setup();// extra modules/component setups 
+  led_setup();
+  buzzer_setup();
+  button_setup();// extra modules/component setups
   
   //------------------------------------------TIMER-------------------------------------------------
   //timer(0, 0, 3, A1_HOUR); // timer for 3 seconds timer(int hour, int minute, int second);
-  //count_second(3); // to test if you have a timer for n seconds, prints seconds in Serial Monitor
+  //count_seconds(3); // to test if you have a timer for n seconds, prints seconds in Serial Monitor
 
   //------------------------------------------ALARM-------------------------------------------------
-  set_daily_alarm(13, 0); // everyday alarm at HH:MM   
+  // set_daily_alarm(13, 0); // everyday alarm at HH:MM
+  set_daily_alarm(AlarmTime {13, 0, 0}); // everyday alarm at HH:MM
 }
 
-
 //---------------------------------------------------------------------ALARM-LOOP----------------------------------------------------------------------------------------------
 
-void loop() {
+static auto current_state = AlarmState::Default;    // current state
+static auto previous_state = AlarmState::AlarmOff;  // previous state
 
+void loop() {
   display_time(); // display the time onto LCD screen (RTC_and_LCD.cpp/h)
 
   //--------------------------------------FINITE-STATE-MACHINE----------------------------------------------
-  
-  static ALARM_STATE alarm_state = ALARM_STATE::DEFAULT_STATE;    // current state 
-  static ALARM_STATE previous_state = ALARM_STATE::DEFAULT_STATE; // previous state 
-  static bool first_state = true;                                 // first state (used for printing)
 
   // function to check and print the state changes
-  check_and_print_current_state(alarm_state, previous_state, first_state);
+  // check_and_print_current_state(current_state, previous_state, first_state);
+
+  if (current_state != previous_state) {
+    print_state(current_state);
+    previous_state = current_state;
+  }
 
-  switch(alarm_state) 
-  {
+  switch (current_state) {
     //-------------------------DEFAULT-------------------------------
-    case ALARM_STATE::DEFAULT_STATE: {
-      // checking if alarm is fired --> DS3231 SQW pin == LOW
-      if ( digitalRead (CLOCK_INTERRUPT_PIN) == LOW ) { 
-        alarm_state = ALARM_STATE::ALARM_ON; }
-      break; } 
-
-    //-------------------------ALARM_ON-------------------------------
-    case ALARM_STATE::ALARM_ON: {
-      beep();
-      if( button_status() == true) { 
-        alarm_state = ALARM_STATE::ALARM_OFF; }
-      break; }    
+  case AlarmState::Default:
+    // checking if alarm is fired --> DS3231 SQW pin == LOW
+    // if (alarm_fired()) { // NOTE (remove before merging): bool alarm_fired() checks if CLOCK_INTERRUPT_PIN is HIGH, is this a mistake?
+    if (digitalRead(CLOCK_INTERRUPT_PIN) == LOW) {
+      current_state = AlarmState::AlarmOn;
+    }
+    break;
+
+    //-------------------------AlarmOn-------------------------------
+  case AlarmState::AlarmOn:
+    beep();
+    if (button_pressed()) {
+      current_state = AlarmState::AlarmOff;
+    }
+    break;
       
-    //-------------------------ALARM_OFF---------------------------
-    case ALARM_STATE::ALARM_OFF: {
-      delete_alarm(1);
-      silence(); 
-      delay(500); // Allow some time for state to stabilize
-      alarm_state = ALARM_STATE::DEFAULT_STATE;
-      break; } 
+    //-------------------------AlarmOff---------------------------
+  case AlarmState::AlarmOff:
+    delete_alarm(Alarm::Alarm1);
+    silence();
+    delay(500); // Allow some time for state to stabilize
+    current_state = AlarmState::Default;
+    break;
 
     //-------------------------DEFAULT-CASE---------------------------
-    default: 
-      alarm_state = ALARM_STATE::DEFAULT_STATE; // Reset to default state to avoid instability
+  default:
+    current_state = AlarmState::Default; // Reset to default state to avoid instability
   }
 }
 
 //---------------------------------------------------------------------EXTRA-FUNCTIONS----------------------------------------------------------------------------------------------
 
-// function to handle and print initial state and state changes for the finite state machine
-void check_and_print_current_state(ALARM_STATE &current_state, ALARM_STATE &previous_state, bool &first_state) {
-  if (first_state) {                      // ^& pass the variables by reference so that new copies of variable arent made
-    print_state(current_state);           //    ^ the purpose of these variables are to track changes 
-    first_state = false; }                //    ^ so by copying them the changes will not reflect outsie this function.
-
-  if (current_state != previous_state) {
-    print_state(current_state); 
-    previous_state = current_state; }
-}
-
 // this prints the current state 
-void print_state(ALARM_STATE state) { //  <---  no need to use & as this is a "read-only" state
-  switch (state) {                    //        plus, enum is lightweight so copying it has little damage to performance              
-    case ALARM_STATE::DEFAULT_STATE:
-      Serial.println(); Serial.println("STATE --> DEFAULT");
-      break;
-
-    case ALARM_STATE::ALARM_ON:      
-      Serial.println(); Serial.println("STATE --> ALARM ON");
-      Serial.println("    Buzzer on, beep. . .");
-      break;
-
-    case ALARM_STATE::ALARM_OFF:
-      Serial.println(); Serial.println("STATE --> ALARM OFF");
-      Serial.println("    Buzzer disabled, silence. . .");
-      break;
-
-    default:
-      Serial.println(); Serial.print("ERROR: Unknown state encountered in ALARM_STATE! State ID: ");
-      // type casting the enum variable "state" to a uint8_t (number from 0-225) 
-      Serial.println(static_cast<uint8_t>(state));  
-      break;}
+void print_state(AlarmState state) { //  <---  no need to use & as this is a "read-only" state
+  switch (state) {                   //        plus, enum is lightweight so copying it has little damage to performance
+  case AlarmState::Default:
+    Serial.println();
+    Serial.println("STATE --> DEFAULT");
+    break;
+
+  case AlarmState::AlarmOn:
+    Serial.println();
+    Serial.println("STATE --> ALARM ON");
+    Serial.println("    Buzzer on, beep. . .");
+    break;
+
+  case AlarmState::AlarmOff:
+    Serial.println();
+    Serial.println("STATE --> ALARM OFF");
+    Serial.println("    Buzzer disabled, silence. . .");
+    break;
+  }
 }
 
 // function to test modules work after new pinouts
-void test_components(void) {
-  if (button_status()) {
-    led_status(1); } // Turn on LED
-  else {
-    led_status(0); } // Turn off LED
+void test_components() {
+  led_status(button_pressed() ? Signal::High : Signal::Low);
 }
 
diff --git a/esp_connection.cpp b/esp_connection.cpp
index 3bea6c5..912d42e 100644
--- a/esp_connection.cpp
+++ b/esp_connection.cpp
@@ -13,13 +13,14 @@
 
 #include "esp_connection.h"
 
-// void read_MAC_address(void) {
+// void read_MAC_address() {
 //   uint8_t baseMac[6];
 //   esp_err_t ret = esp_wifi_get_mac(WIFI_IF_STA, baseMac);
 //   if (ret == ESP_OK) {
 //     Serial.printf("%02x:%02x:%02x:%02x:%02x:%02x\n",
 //                   baseMac[0], baseMac[1], baseMac[2],
-//                   baseMac[3], baseMac[4], baseMac[5]); } 
-//   else {
-//     Serial.println("Failed to read MAC address"); }
+//                   baseMac[3], baseMac[4], baseMac[5]);
+//    } else {
+//      Serial.println("Failed to read MAC address");
+//    }
 // }
diff --git a/esp_connection.h b/esp_connection.h
index c3d2845..5685a73 100644
--- a/esp_connection.h
+++ b/esp_connection.h
@@ -7,5 +7,4 @@
 #include <esp_now.h>
 #include <WiFi.h>
 
-// void read_MAC_address(void);
-
+// void read_MAC_address();
diff --git a/functions.cpp b/functions.cpp
index 563cedf..c6a5f2c 100644
--- a/functions.cpp
+++ b/functions.cpp
@@ -9,65 +9,73 @@
 //-------------------------------------------------------------------SERIAL------------------------------------------------------------------------------------------------
 
 // functions.cpp --- sets up the serial monitor
-void serial_setup(void) {
+void serial_setup() {
   Serial.begin(9600); // Setup for serial monitor 
-  while (!Serial); }
+  while (!Serial);
+}
 
 //-------------------------------------------------------------------BUZZER------------------------------------------------------------------------------------------------
 // functions.cpp --- setting up the buzzer
-void buzzer_setup(void) {
+void buzzer_setup() {
   pinMode(BUZZER_PIN, OUTPUT);
   digitalWrite(BUZZER_PIN, LOW); 
 }
 
 // functions.cpp --- shut the buzzer up
-void silence(void) {
+void silence() {
   digitalWrite(BUZZER_PIN, LOW); 
 }
 
 // functions.cpp --- buzzer beeping noise 
-void beep(void) {
+void beep() {
   digitalWrite(BUZZER_PIN, HIGH); 
 }
 
 //-------------------------------------------------------------------LED------------------------------------------------------------------------------------------------
 
 // functions.cpp --- void function, sets up the LED_PINs 
-void led_setup(void) {
+void led_setup() {
   pinMode(LED_PIN, OUTPUT); 
-  }
+}
 
 // functions.cpp --- a void function with parameters 1 to turn on LED, 0 to turn it off.
-void led_status(int status) {
-  if (status == 1) {
-    digitalWrite(LED_PIN, HIGH); }
-  else if (status == 0) {
-    digitalWrite(LED_PIN, LOW); }
-  else {
-    Serial.println("LED function input must be 0 or 1"); }
+void led_status(Signal status) {
+  switch (status) {
+  case Signal::High:
+    digitalWrite(LED_PIN, HIGH);
+    break;
+  case Signal::Low:
+    digitalWrite(LED_PIN, LOW);
+    break;
+  default:
+    Serial.println("LED function input must be 0 or 1");
+  }
 }
 
 //-------------------------------------------------------------------BUTTON------------------------------------------------------------------------------------------------
 
 // functions.cpp --- sets up the button pins, attatches a silence interupt.
-void button_setup(void) {
+void button_setup() {
   pinMode(BUTTON_PIN, INPUT);  // setting button to be an input pin 
   // attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), on_button, FALLING); 
   //    ^ uncommented because not needed with FSM, but maybe can include if you want
 }
 
 // functions.cpp --- checks if button has been pressed + debounce checker of 50ms
-bool button_status(void) {
-  static unsigned long prev_btn_time = 0;   // tracks the previous press time which is initially 0 
-  const unsigned long DEBOUNCE_DELAY = 50;  // constant debounce variable
-  unsigned long current_time = millis();
-
-  if(digitalRead(BUTTON_PIN) == HIGH) {
-    if (current_time - prev_btn_time > DEBOUNCE_DELAY) {
-      prev_btn_time = current_time;}
-    return true; }
-  else {
-    return false; }
+bool button_pressed() {
+  static auto prev_btn_time = 0;   // tracks the previous press time which is initially 0
+  constexpr auto DEBOUNCE_DELAY = 50;  // constant debounce variable
+
+  const auto current_time = millis();
+
+  if (digitalRead(BUTTON_PIN) == HIGH) {
+    if ((current_time - prev_btn_time) > DEBOUNCE_DELAY) {
+      prev_btn_time = current_time;
+    }
+    return true;
+  } else {
+    return false;
+  }
 }
 
 // functions.cpp --- if button is on, it will serial print ("Button pressed!")
@@ -79,16 +87,16 @@ void on_button() {
 //-------------------------------------------------------------------MISC------------------------------------------------------------------------------------------------
 
 // functions.cpp --- counts 3 seconds without delay, doesnt work tho, i'll sort that out later
-void count_second(int n) {
-  static unsigned long timer_millis = millis();
-  const int one_sec = 1000;
+void count_seconds(int n) {
+  constexpr auto one_sec = 1000;
+  auto timer_millis = millis();
 
-  for (int i = 1; i <= n; i++) { // Loop n times
-    if (millis() - timer_millis > one_sec ) {
+  for (int i = 0; i < n;) { // Loop n times
+    if ((millis() - timer_millis) > one_sec) {
       Serial.println(n);
-      timer_millis = millis(); } }
-}
-
-
-
 
+      timer_millis = millis();
+      ++i;
+    }
+  }
+}
diff --git a/functions.h b/functions.h
index d57c714..ec9d3ea 100644
--- a/functions.h
+++ b/functions.h
@@ -5,29 +5,31 @@
 
 #include <Arduino.h>
 
-#define LED_PIN 1 // for when you have an LED
-#define BUTTON_PIN 2  
-#define BUZZER_PIN 3
+constexpr auto LED_PIN = 1; // for when you have an LED
+constexpr auto BUTTON_PIN = 2;
+constexpr auto BUZZER_PIN = 3;
+
+enum class Signal { Low, High };
 
 //------------------------SERIAL----------------------------
 
-void serial_setup(void);  // serial monitor begin setup
+void serial_setup();  // serial monitor begin setup
 
 //------------------------LED-------------------------------
 
-void buzzer_setup(void);  // buzzer setup pins
-void silence(void);       // silences buzzer
-void beep(void);          // beeps the buzzer
+void buzzer_setup();  // buzzer setup pins
+void silence();       // silences buzzer
+void beep();          // beeps the buzzer
 
 //------------------------LED-------------------------------
 
-void led_setup(void);     // sets up LEDs
-void led_status(int status); // toggles LED on or off
+void led_setup();     // sets up LEDs
+void led_status(Signal status); // toggles LED on or off
 
 //------------------------BUTTON----------------------------
 
-void button_setup(void);  // button setup
-bool button_status(void); // checks if button has been pressed
+void button_setup();  // button setup
+bool button_pressed(); // checks if button has been pressed
 void on_button();         // button pressed serial print message
 
 //------------------------MISC------------------------------
